<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS - Arrow Functions</title>
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/header.css">
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/content.css">

</head>
<body>
    <header class="header">
        <div class="header__insideContainer">
            <h1 class="header__title">Javascript - Arrow Functions</h1>
        </div>
    </header>
    <body class="body">
        <main class="main">
            <div class="container">
                <nav class="menu">
                    <div class="menu__left">
                        <div class="menu__icon"></div>
                    </div>
                    <div class="menu__right">
                        <ul>
                            <li>Lorem ipsum, dolor sit amet consectetur adipisicing elit. Quidem corrupti, at quaerat vero totam vitae quasi possimus! Voluptatibus aperiam consequatur quidem! Labore cum laborum, officiis enim qui atque sunt illum.</li>
                            <li>Sunt minima sapiente accusantium enim tempore veritatis veniam laboriosam nemo corporis repellendus! Neque veritatis sunt quae aliquam consequatur eum fugiat minus blanditiis maxime. Illo, facere sint et nobis necessitatibus sequi?</li>
                            <li>Facilis expedita cupiditate reiciendis similique doloremque explicabo itaque odit laboriosam ab quaerat obcaecati a exercitationem beatae modi perferendis dolorem sapiente, eaque sint nesciunt facere. Quae odio ex reprehenderit harum fugiat?</li>
                            <li>Architecto laudantium iure earum porro reiciendis, quaerat, aliquid dolores dolorem optio aut tempore quam assumenda ipsum, illo error deleniti et voluptas facilis modi dicta quisquam omnis incidunt? Aperiam, optio eaque.</li>
                            <li>Commodi, pariatur consequuntur voluptate officiis expedita vero, quo accusantium, culpa deleniti laboriosam illum itaque harum velit modi perspiciatis? Omnis impedit illum corrupti reiciendis ea eveniet nostrum obcaecati veniam eum fugiat.</li>
                        </ul>
                    </div>
                </nav>
                <div class="content">
                    <section class="content__section">
                        <h2>Arrow function expressions</h2>
                        
                        <p class="section__paragraph">
                            An arrow function expression is a compact alternative to a traditional function expression, but is limited and can't be used in all situations.
                        </p>
                        <p class="section__paragraph">
                            There are differences between arrow functions and traditional functions, as well as some limitations:
                        </p>
                        <p class="section__paragraph">
                            <ul>
                                <li>
                                    Arrow functions don't have their own bindings to this, arguments or super, and should not be used as methods.
                                </li>
                                <li>
                                    Arrow functions don't have access to the new.target keyword.
                                </li>
                                <li>
                                    Arrow functions aren't suitable for call, apply and bind methods, which generally rely on establishing a scope.
                                </li>
                                <li>
                                    Arrow functions cannot be used as constructors.
                                </li>
                                <li>
                                    Arrow functions cannot use yield, within its body.
                                </li>
                            </ul>
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Comparing traditional functions to arrow functions</h3>
                        <p class="section__paragraph">
                            Let's decompose a "traditional anonymous function" down to the simplest "arrow function" step-by-step:
                        </p>
                        <p class="section__code">
                                // Traditional Anonymous Function
                                (function (a) {
                                return a + 100;
                                });

                                // Arrow Function Break Down

                                // 1. Remove the word "function" and place arrow between the argument and opening body bracket
                                (a) => {
                                return a + 100;
                                };

                                // 2. Remove the body braces and word "return" — the return is implied.
                                (a) => a + 100;

                                // 3. Remove the argument parentheses
                                a => a + 100;
                        </p>
                        <p class="section__paragraph">
                            The { braces } and ( parentheses ) and "return" are required in some cases.
                        </p>
                        <p class="section__paragraph">
                            For example, if you have multiple arguments or no arguments, you'll need to re-introduce parentheses around the arguments:
                        </p>
                        <p class="section__code">
                                // Traditional Anonymous Function
                                (function (a, b) {
                                return a + b + 100;
                                });

                                // Arrow Function
                                (a, b) => a + b + 100;

                                const a = 4;
                                const b = 2;

                                // Traditional Anonymous Function (no arguments)
                                (function() {
                                return a + b + 100;
                                });

                                // Arrow Function (no arguments)
                                () => a + b + 100;
                        </p>
                        <p class="section__paragraph">
                            Likewise, if the body requires additional lines of processing, you'll need to re-introduce braces PLUS the "return" (arrow functions do not magically guess what or when you want to "return"):
                        </p>
                        <p class="section__code">
                            // Traditional Anonymous Function
                            (function (a, b) {
                            const chuck = 42;
                            return a + b + chuck;
                            });

                            // Arrow Function
                            (a, b) => {
                            const chuck = 42;
                            return a + b + chuck;
                            };
                        </p>
                        <p class="section__paragraph">
                            And finally, for named functions we treat arrow expressions like variables:
                        </p>
                        <p class="section__code">
                            // Traditional Function
                            function bob(a) {
                            return a + 100;
                            }

                            // Arrow Function
                            const bob2 = (a) => a + 100;
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Basic syntax</h3>
                        <p class="section__paragraph">One param. With simple expression return is not needed:</p>

                        <p class="section__code">
                            param => expression
                            (param) => expression
                        </p>
                        <p class="section__paragraph">
                            Multiple params require parentheses. With simple expression return is not needed:
                        </p>
                        <p class="section__code">
                            (param1, paramN) => expression
                        </p>
                        <p class="section__paragraph">
                            Multiline statements require body braces and return:
                        </p>
                        <p class="section__code">
                            // The parentheses are optional with one single parameter
                            (param) => {
                            const a = 1;
                            return a + param;
                            }
                        </p>
                        <p class="section__paragraph">                           
                            Multiple params require parentheses. Multiline statements require body braces and return:
                        </p>
                        <p class="section__code">
                            (param1, paramN) => {
                            const a = 1;
                            return a + param1 + paramN;
                            }
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Advanced syntax</h3>
                        <p class="section__paragraph">
                            To return an object literal expression requires parentheses around expression:
                        </p>    
                        <p class="section__code">
                            (params) => ({ foo: "a" }) // returning the object { foo: "a" }
                        </p>
                        <p class="section__paragraph">
                            Rest parameters are supported, and always require parentheses:
                        </p>
                        <p class="section__code">
                            (a, b, ...r) => expression
                        </p>
                        <p class="section__paragraph">
                            Default parameters are supported, and always require parentheses:
                        </p>
                        <p class="section__code">
                            (a=400, b=20, c) => expression
                        </p>
                        <p class="section__paragraph">
                            Destructuring within params is supported, and always requires parentheses:
                        </p>
                        <p class="section__code">
                            ([a, b] = [10, 20]) => a + b;  // result is 30
                            ({ a, b } = { a: 10, b: 20 }) => a + b; // result is 30
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Arrow functions used as methods</h3>
                        <p class="section__paragraph">
                            As stated previously, arrow function expressions are best suited for non-method functions. Let's see what happens when we try to use them as methods:
                        </p>
                        <p class="section__code">
                            'use strict';

                            const obj = { // does not create a new scope
                            i: 10,
                            b: () => console.log(this.i, this),
                            c() {
                                console.log(this.i, this);
                            },
                            }

                            obj.b(); // prints undefined, Window { /* … */ } (or the global object)
                            obj.c(); // prints 10, Object { /* … */ }
                        </p>
                        <p class="section__paragraph">
                            Arrow functions do not have their own this. Another example involving Object.defineProperty():
                        </p>
                        <p class="section__code">
                            'use strict';

                            const obj = {
                            a: 10,
                            };

                            Object.defineProperty(obj, 'b', {
                            get: () => {
                                console.log(this.a, typeof this.a, this); // undefined 'undefined' Window { /* … */ } (or the global object)
                                return this.a + 10; // represents global object 'Window', therefore 'this.a' returns 'undefined'
                            },
                            });
                        </p>
                        <p class="section__paragraph">
                            Because a class's body has a this context, arrow functions as class fields close over the class's this context and the this inside the arrow function's body will correctly point to the instance (or the class itself, for static fields). However, because it is a closure, not the function's own binding, the value of this will not change based on the execution context.
                        </p>
                        <p class="section__code">    
                            class C {
                            a = 1;
                            autoBoundMethod = () => {
                                console.log(this.a);
                            }
                            }

                            const c = new C();
                            c.autoBoundMethod(); // 1
                            const { autoBoundMethod } = c;
                            autoBoundMethod(); // 1
                            // If it were a normal method, it should be undefined in this case
                        </p>
                        <p class="section__paragraph">
                            Arrow function properties are often said to be "auto-bound methods", because the equivalent with normal methods is:
                        </p>
                        <p class="section__code">
                            class C {
                            a = 1;
                            constructor() {
                                this.method = this.method.bind(this);
                            }
                            method() {
                                console.log(this.a);
                            }
                            }
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>call, apply and bind</h3>
                        <p class="section__paragraph">
                            The call, apply and bind methods are NOT suitable as arrow functions – as they were designed to allow methods to execute within different scopes – because arrow functions establish this based on the scope the arrow function is defined within.

                            For example call, apply and bind work as expected with traditional functions, because we establish the scope for each of the methods:
                        </p>
                        <p class="section__code">
                            // ----------------------
                            // Traditional Example
                            // ----------------------
                            // A simplistic object with its very own "this".
                            const obj = {
                            num: 100,
                            };

                            // Setting "num" on window to show how it is NOT used.
                            window.num = 2020; // yikes!

                            // A simple traditional function to operate on "this"
                            const add = function (a, b, c) {
                            return this.num + a + b + c;
                            };

                            // call
                            const resultCall = add.call(obj, 1, 2, 3); // establishing the scope as "obj"
                            console.log(resultCall); // result 106

                            // apply
                            const arr = [1, 2, 3];
                            const resultApply = add.apply(obj, arr); // establishing the scope as "obj"
                            console.log(resultApply); // result 106

                            // bind
                            const resultBind = add.bind(obj); // establishing the scope as "obj"
                            console.log(resultBind(1, 2, 3)); // result 106
                            Copy to Clipboard
                            With arrow functions, since our add function is essentially created on the window (global) scope, it will assume this is the window.

                            // ----------------------
                            // Arrow Example
                            // ----------------------

                            // A simplistic object with its very own "this".
                            const obj = {
                            num: 100,
                            };

                            // Setting "num" on window to show how it gets picked up.
                            window.num = 2020; // yikes!

                            // Arrow Function
                            const add = (a, b, c) => this.num + a + b + c;

                            // call
                            console.log(add.call(obj, 1, 2, 3)); // result 2026

                            // apply
                            const arr = [1, 2, 3];
                            console.log(add.apply(obj, arr)); // result 2026

                            // bind
                            const bound = add.bind(obj);
                            console.log(bound(1, 2, 3)); // result 2026
                        </p>
                        <p class="section__paragraph">
                            Perhaps the greatest benefit of using Arrow functions is with methods like setTimeout() and EventTarget.addEventListener() that usually require some kind of closure, call, apply or bind to ensure that the function is executed in the proper scope.
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Traditional function example</h3>
                        <p class="section__code">
                            const obj = {
                            count: 10,
                            doSomethingLater() {
                                setTimeout(function () { // the function executes on the window scope
                                this.count++;
                                console.log(this.count);
                                }, 300);
                            },
                            };

                            obj.doSomethingLater(); // console prints "NaN", because the property "count" is not in the window scope.
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Arrow function example</h3>
                        <p class="section__code">
                            const obj = {
                            count: 10,
                            doSomethingLater () {
                                // The traditional function binds "this" to the "obj" context.
                                setTimeout(() => {
                                // Since the arrow function doesn't have its own binding and
                                // setTimeout (as a function call) doesn't create a binding
                                // itself, the "obj" context of the traditional function will
                                // be used within.
                                this.count++;
                                console.log(this.count);
                                }, 300);
                            },
                            };

                            obj.doSomethingLater();
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>No binding of arguments</h3>
                        <p class="section__paragraph">
                            Arrow functions do not have their own arguments object. Thus, in this example, arguments is a reference to the arguments of the enclosing scope:
                        </p>
                        <p class="section__code">    
                            const arguments = [1, 2, 3];
                            const arr = () => arguments[0];

                            arr(); // 1

                            function foo(n) {
                            const f = () => arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n
                            return f();
                            }

                            foo(3); // 3 + 3 = 6
                        </p>
                        <p class="section__paragraph">
                            In most cases, using rest parameters is a good alternative to using an arguments object.
                        </p>
                        <p class="section__code">
                            function foo(n) {
                            const f = (...args) => args[0] + n;
                            return f(10);
                            }

                            foo(1); // 11
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Use of the new operator</h3>
                        <p class="section__paragraph">
                            Arrow functions cannot be used as constructors and will throw an error when used with new.
                        </p>
                        <p class="section__code">
                            const Foo = () => {};
                            const foo = new Foo(); // TypeError: Foo is not a constructor
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Use of prototype property</h3>
                        <p class="section__paragraph">
                            Arrow functions do not have a prototype property.
                        </p>
                        <p class="section__code">
                            const Foo = () => {};
                            console.log(Foo.prototype); // undefined
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Use of the yield keyword</h3>
                        <p class="section__paragraph">
                            The yield keyword may not be used in an arrow function's body (except when permitted within functions further nested within it). As a consequence, arrow functions cannot be used as generators.
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Function body</h3>
                        <p class="section__paragraph">
                            Arrow functions can have either a concise body or the usual block body.

                            In a concise body, only an expression is specified, which becomes the implicit return value. In a block body, you must use an explicit return statement.
                        </p>
                        <p class="section__code">
                            const func = (x) => x * x;
                            // concise body syntax, implied "return"

                            const func2 = (x, y) => { return x + y; };
                            // with block body, explicit "return" needed
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Returning object literals</h3>
                        <p class="section__paragraph">
                            Keep in mind that returning object literals using the concise body syntax (params) => {object:literal} will not work as expected.
                        </p>
                        <p class="section__code">
                            const func = () => { foo: 1 };
                            // Calling func() returns undefined!

                            const func2 = () => { foo: function () {} };
                            // SyntaxError: function statement requires a name

                            const func3 = () => { foo() {} };
                            // SyntaxError: Unexpected token '{'
                        </p>
                        <p class="section__paragraph">
                            This is because the code inside braces ({}) is parsed as a sequence of statements (i.e. foo is treated like a label, not a key in an object literal).

                            You must wrap the object literal in parentheses:
                        </p>
                        <p class="content_quote">
                            const func = () => ({ foo: 1 });
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Line breaks</h3>
                        <p class="section__paragraph">
                            An arrow function cannot contain a line break between its parameters and its arrow.
                        </p>
                        <p class="section__code">
                            const func = (a, b, c)
                            => 1;
                            // SyntaxError: Unexpected token '=>'
                        </p>
                        <p class="section__paragraph">
                            However, this can be amended by putting the line break after the arrow or using parentheses/braces as seen below to ensure that the code stays pretty and fluffy. You can also put line breaks between arguments.
                        </p>
                        <p class="section__code">
                            const func = (a, b, c) =>
                            1;

                            const func2 = (a, b, c) => (
                            1
                            );

                            const func3 = (a, b, c) => {
                            return 1;
                            };

                            const func4 = (
                            a,
                            b,
                            c
                            ) => 1;

                            // no SyntaxError thrown
                        </p>
                    </section>
                    <section class="content__section">
                        <h3>Parsing order</h3>
                        <p class="section__paragraph">
                            Although the arrow in an arrow function is not an operator, arrow functions have special parsing rules that interact differently with operator precedence compared to regular functions.
                        </p>
                        <p class="section__code"> 
                            let callback;

                            callback = callback || () => {};
                            // SyntaxError: invalid arrow-function arguments
                        </p>
                        <p class="section__paragraph">
                            Because => has a lower precedence than most operators, parentheses are necessary to avoid callback || () being parsed as the arguments list of the arrow function.
                        </p>
                        <p class="section__code">
                            callback = callback || (() => {});    // ok
                        </p>
                    </section>
                </div>
            </div>
        </main>
    </body>
    <footer class="footer">
        <p class="footer__text"></p>
    </footer>
</body>
</html>